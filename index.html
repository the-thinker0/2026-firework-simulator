<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>马年年会烟花秀 - 至臻完美版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: "Microsoft YaHei", sans-serif; }
        canvas { display: block; }
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.85); color: #fff; z-index: 10; cursor: pointer;
        }
        h1 { margin: 0 0 20px; font-size: 3em; text-shadow: 0 0 20px #ff0055; letter-spacing: 5px; }
        p { font-size: 1.2em; color: #ddd; background: rgba(255,255,255,0.1); padding: 10px 20px; border-radius: 20px; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>马年新春 · 盛大烟花秀</h1>
        <p>► 点击屏幕启动 | 按 F 键全屏</p>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // ================= 核心配置 =================
        const CONFIG = {
            beatTime: 60 / 124, // 0.483s
            words: ["青风骏业", "万马奔腾", "骏驰青春", "青聚骏腾", "乐跃马年", "骏采青扬", "一马当先", "马到成功", "聚力破局", "乘风而上"],
            endWords: ["致敬青春", "致敬奋斗", "马年大吉", "新春快乐"],
            density: 5,           // 文字粒子密度
            particleRadius: 2.2,  // 文字粒子半径
            textBrightness: 85    // 文字亮度
        };

        const audio = new Audio('Green Apple Paradise.mp3');
        const logoImg = new Image();
        logoImg.src = 'logo.png'; 

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height, isRunning = false;
        let particles = [], fireworks = [];
        const textCanvas = document.createElement('canvas');
        const textCtx = textCanvas.getContext('2d');

        let displayTime = 0;
        let lastFrameTimestamp = 0;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        // ================= 物理粒子类 =================
        class Firework {
            constructor(targetX, targetY, text = '', type = 'normal', isFinal = false) {
                this.startFromTop = Math.random() > 0.6; 
                this.x = Math.random() * width;
                this.y = this.startFromTop ? 0 : height;

                this.targetX = targetX;
                this.targetY = targetY;
                this.text = text;
                this.type = type; 
                this.isFinal = isFinal; 
                this.speed = 22;
                this.angle = Math.atan2(targetY - this.y, targetX - this.x);
                this.coordinates = [[this.x, this.y], [this.x, this.y], [this.x, this.y]];
                this.baseHue = Math.random() * 360; 
            }
            update(index) {
                this.coordinates.pop();
                this.coordinates.unshift([this.x, this.y]);
                this.speed *= 1.04;
                const vx = Math.cos(this.angle) * this.speed;
                const vy = Math.sin(this.angle) * this.speed;
                if (Math.hypot(this.targetX - this.x, this.targetY - this.y) < this.speed) {
                    if (this.text) createParticleText(this.targetX, this.targetY, this.text, this.isFinal);
                    else createParticles(this.targetX, this.targetY);
                    fireworks.splice(index, 1);
                } else {
                    this.x += vx; this.y += vy;
                }
            }
            draw() {
                ctx.beginPath();
                ctx.moveTo(this.coordinates[this.coordinates.length - 1][0], this.coordinates[this.coordinates.length - 1][1]);
                ctx.lineTo(this.x, this.y);
                ctx.strokeStyle = `hsl(${this.baseHue}, 100%, 60%)`;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        class Particle {
            constructor(x, y, hue, type) {
                this.x = x; this.y = y; this.type = type; 
                
                if (type === 'normal') {
                    this.hue = Math.random() * 360;
                } else {
                    this.hue = hue; 
                }

                this.alpha = 1;
                
                if (type === 'normal') {
                    this.angle = Math.random() * Math.PI * 2;
                    // --- 修改点: 略微增加速度范围，让烟花炸得更开 ---
                    this.speed = Math.random() * 14 + 1.5; 
                    this.friction = 0.95;
                    this.gravity = 0.8;
                    this.decay = Math.random() * 0.015 + 0.01;
                    this.brightness = Math.random() * 40 + 50;
                } else if (type === 'text') {
                    this.angle = Math.random() * Math.PI * 2;
                    this.speed = Math.random() * 2.5; 
                    this.friction = 0.5; 
                    this.gravity = 0;  
                    this.decay = 0.008;  
                    this.brightness = CONFIG.textBrightness;
                } else if (type === 'frozen') {
                    this.originX = x; this.originY = y;
                    this.decay = 0; this.speed = 0;
                    this.brightness = CONFIG.textBrightness + 10;
                    this.shimmer = Math.random() * 10;
                }
            }
            update(index) {
                if (this.type === 'frozen') {
                    this.shimmer += 0.05;
                    this.alpha = 0.8 + Math.sin(this.shimmer) * 0.2;
                    this.x = this.originX + Math.sin(this.shimmer) * 0.5;
                    return;
                }
                this.speed *= this.friction;
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed + this.gravity;
                this.alpha -= this.decay;
                if (this.alpha <= 0) particles.splice(index, 1);
            }
            draw() {
                if (this.type === 'frozen') {
                    ctx.fillStyle = `hsla(45, 100%, 60%, ${this.alpha})`;
                } else if (this.type === 'text') {
                    let lightness = 60 + (1 - this.alpha) * 40;
                    ctx.fillStyle = `hsla(45, 100%, ${lightness}%, ${this.alpha})`;
                } else {
                    ctx.fillStyle = `hsla(${this.hue}, 100%, ${this.brightness}%, ${this.alpha})`;
                }
                
                ctx.beginPath();
                // --- 修改点: 半径设为1.8 ---
                // 1.8 既比原来的1.3大，又比模糊的2.5小，保持清晰度
                let r = (this.type !== 'normal') ? CONFIG.particleRadius : 1.8;
                ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ================= 生成逻辑 =================
        function createParticles(x, y) {
            let hue = Math.random() * 360;
            // --- 修改点: 保持高密度 (350) ---
            for(let i=0; i<350; i++) particles.push(new Particle(x, y, hue, 'normal'));
        }

        function createParticleText(x, y, text, isFinal) {
            let fontSize;
            if (CONFIG.words.includes(text)) {
                fontSize = Math.min(280, width * 0.7 / text.length);
            } else {
                let maxW = width * 0.22; 
                fontSize = Math.min(220, maxW / text.length * 2.2);
            }

            textCtx.font = `bold ${fontSize}px Microsoft YaHei`;
            const tWidth = textCtx.measureText(text).width;
            textCanvas.width = tWidth + 40;
            textCanvas.height = fontSize * 1.5;
            
            textCtx.clearRect(0,0, textCanvas.width, textCanvas.height);
            textCtx.font = `bold ${fontSize}px Microsoft YaHei`;
            textCtx.fillStyle = "white"; 
            textCtx.textAlign = "center";
            textCtx.textBaseline = "middle";
            textCtx.fillText(text, textCanvas.width/2, textCanvas.height/2);

            const data = textCtx.getImageData(0,0, textCanvas.width, textCanvas.height).data;
            const type = isFinal ? 'frozen' : 'text';
            for(let i=0; i<textCanvas.height; i+=CONFIG.density) {
                for(let j=0; j<textCanvas.width; j+=CONFIG.density) {
                    if(data[(i * textCanvas.width + j) * 4 + 3] > 128) {
                        particles.push(new Particle(x + j - textCanvas.width/2, y + i - textCanvas.height/2, 45, type));
                    }
                }
            }
        }

        // ================= 时间轴逻辑 =================
        let nextShotTime = 0;
        let lastMainWordTime = -6; 
        let mainWordIndex = 0;
        let endPhase = 0; 
        let lastEndSeq = -1; 

        function handleRhythm(time) {
            if (time < nextShotTime) return;

            let interval = CONFIG.beatTime;
            let waveCount = 1;

            if (time < 3) {
                waveCount = 2;
            } else if (time < 70) {
                // 主歌部分
                if (time - lastMainWordTime >= 6 && mainWordIndex < CONFIG.words.length) {
                    const tx = width * (0.3 + Math.random() * 0.4);
                    const ty = height * (0.25 + Math.random() * 0.3);
                    fireworks.push(new Firework(tx, ty, CONFIG.words[mainWordIndex], 'text'));
                    mainWordIndex++;
                    lastMainWordTime = time;
                }
                waveCount = 4;
            } else if (time >= 70 && time < 78) {
                // 尾奏预热
                let seq = Math.floor((time - 70) / 2);
                if (seq < 4 && seq > lastEndSeq) {
                    const pos = getEndPos(seq);
                    createParticleText(width * pos.x, height * pos.y, CONFIG.endWords[seq], false);
                    lastEndSeq = seq;
                }
                waveCount = 4; 
                interval = CONFIG.beatTime; 
            } else if (time >= 78) {
                // 终极定格
                if (endPhase < 2) {
                    endPhase = 2;
                    particles = particles.filter(p => p.type === 'text'); 
                    CONFIG.endWords.forEach((word, idx) => {
                        const pos = getEndPos(idx);
                        createParticleText(width * pos.x, height * pos.y, word, true);
                    });
                }
                waveCount = 7; 
                interval = CONFIG.beatTime * 0.6; 
            }

            for(let k=0; k<waveCount; k++) {
                setTimeout(() => {
                    const tx = Math.random() * width;
                    const ty = Math.random() * height * 0.6 + height * 0.2; 
                    fireworks.push(new Firework(tx, ty));
                }, k * 50); 
            }
            nextShotTime = time + interval;
        }

        function getEndPos(idx) {
            const offset = 0.18;
            const p = [
                {x: 0.5, y: offset},          
                {x: 1 - offset - 0.05, y: 0.5},
                {x: 0.5, y: 1 - offset},      
                {x: offset + 0.05, y: 0.5}      
            ];
            return p[idx];
        }

        // ================= 循环 =================
        function loop(timestamp) {
            if (!isRunning) return;
            requestAnimationFrame(loop);
            
            if (!lastFrameTimestamp) lastFrameTimestamp = timestamp;
            const deltaTime = (timestamp - lastFrameTimestamp) / 1000;
            lastFrameTimestamp = timestamp;

            if (!audio.paused) {
                displayTime = audio.currentTime;
            } else if (isRunning && displayTime > 0) {
                displayTime += deltaTime;
            }

            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.18)'; 
            ctx.fillRect(0, 0, width, height);
            ctx.globalCompositeOperation = 'lighter';

            // Logo 淡入
            if (displayTime >= 70) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                const logoW = Math.min(width * 0.35, 420);
                const logoH = logoW * (logoImg.height / logoImg.width || 1);
                ctx.globalAlpha = Math.min(0.9, (displayTime - 70) / 4);
                if (logoImg.complete) ctx.drawImage(logoImg, (width-logoW)/2, (height-logoH)/2, logoW, logoH);
                ctx.restore();
                ctx.globalCompositeOperation = 'lighter';
            }

            fireworks.forEach((f, i) => { f.draw(); f.update(i); });
            particles.forEach((p, i) => { p.draw(); p.update(i); });
            
            if (particles.length > 15000) {
                particles = particles.filter((p, i) => p.type !== 'normal' || i > particles.length - 10000);
            }

            handleRhythm(displayTime);
        }

        document.getElementById('start-screen').addEventListener('click', function() {
            this.style.opacity = 0;
            setTimeout(() => this.style.display = 'none', 500);
            audio.play().catch(e => console.log("Audio play failed"));
            isRunning = true;
            lastFrameTimestamp = performance.now();
            requestAnimationFrame(loop);
        });

        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'f' && !document.fullscreenElement) canvas.requestFullscreen();
        });
    </script>
</body>
</html>